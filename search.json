[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Jesse Onland",
    "section": "",
    "text": "Iâ€™m a data scientist at Samos in Kitchener, Ontario, Canada.\nIâ€™m interested in inference broadly construed. That includes symbolic logic, mathematical proof, statistical inference, machine learning, and other topics related to knowing what we ought to conclude from the facts available to us.\nMy motto is, â€œIf mathematics were cheesecake, I wouldnâ€™t be a piano tuner.â€ Ask me about it some time!"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "1 + 1\n\n[1] 2"
  },
  {
    "objectID": "links.html",
    "href": "links.html",
    "title": "Links",
    "section": "",
    "text": "Here are some things on the Web that Iâ€™ve found interesting, useful, or impactful.\n\nðŸŽ¨ Art\n\nThis Man Has Spent 30 Years Mapping the Imaginary Land of Ukrania\nRagna RÃ³bertsdÃ³ttir\nSelected Works by M. C. Escher\nSelected Piet Mondrian Paintings\nHenry Darger\nGerd Arntz Web Archive\nFranÃ§ois Avril\n104 Mesmerizing Mosque Ceilings That Highlight The Wonders Of Islamic Architecture\nTauba Aurebach - Works\n\n\n\nðŸ™ï¸ Cities\n\n50 Reasons Why Everyone Should Want More Walkable Streets\nWhat I Mean When I Say â€˜Ban Carsâ€™\nThe People Who Hate People\nStroads are Ugly, Expensive, and Dangerous (and theyâ€™re everywhere)\nWhatâ€™s a Gadgetbahn?\nShifting gears: why US cities are falling out of love with the parking lot\nEvery NIMBYâ€™s Speech at a Public Hearing\nThereâ€™s No Such Thing as Affordable Housing\nIvan Illich on Cars\nWhy Canadian cities just generally suck\nThe housing theory of everything\nWhy Is Japanese Zoning More Liberal Than US Zoning?\n\n\n\nðŸ› Consumer Goods\n\nHow To Judge Quality In Clothing\nShaving Is Too Expensive. Also the world is out to get you\nThe Kitchen Starter Kit: Essential Tools for Every Cook\nYour stuff is actually worse now\nLetâ€™s talk about margins\n\n\n\nðŸ›ï¸ Culture & Politics\n\nCanada is fake\nIs Culture Snobbery The New Resistance?\nA decade of sore winners\nWhat Moneyball-for-Everything Has Done to American Culture\nWe Live In The Age of The Bullshitter\nThe age of average\n\n\n\nðŸ“Š Data Science\n\nData Science: Reality Doesnâ€™t Meet Expectations\nThe weirdest paradox in statistics (and machine learning)\nReview of Probability Theory: The Logic of Science\nThe Good Research Code Handbook\nThinking Clearly About Correlations and Causation: Graphical Causal Models for Observational Data\nCommon statistical tests are linear models (or: how to teach stats)\nGoodbye, Data Science\nProbability that a number is prime\nPhilosophy of Probability\nWhy Business Data Science Irritates Me\nSimpsonâ€™s paradox all the way down\nPhilosophy of Statistics\nOn Moving from Statistics to Machine Learning, the Final Stage of Grief\nNever Test for Normality\nStats canâ€™t make modeling decisions\nMost Data Work Seems Fundamentally Worthless\n1 dataset 100 visualizations\nThe Shortcomings of Standardized Regression Coefficients\nWhat Is Probability?\nCan you have confidence in a confidence interval?\nDirected Acyclic Graphs\nSimulating confounders, colliders and mediators\nHow People Actually Lie With Charts\n\n\n\nðŸŽ² Games\n\nhangman is a weird game\nAngry Birds, Farmville and Other Hyperaddictive â€˜Stupid Gamesâ€™\n1000 Blank White Cards Wiki\nZendoâ€”Design History\n\n\n\nðŸ—£ï¸ Language\n\nUtopian for Beginners\nThe Interpreter\nNo BÃ©arla\nWhat Consonant Clusters are Possible?\nWhy is English so weirdly different from other languages?\nWhy language might be the optimal self-regulating system\nIPA: Symbols of Power?\nThe vowel space\n\n\n\nðŸ“š Learning\n\nHow To Understand Things\nHow to Self-Study Math\nEffectively self-studying over theÂ Internet\n\n\n\nðŸ’µ Money\n\nThereâ€™s Nothing to Do Except Gamble\nThe Singular Pursuit of Comrade Bezos\nFinding and Funding a Good Life\nThe Homeownership Society Was a Mistake\nYes, Crypto is ALL a Scam\nMaybe Treating Housing as an Investment was a Colossal, Society-Shattering Mistake\nOn the Phenomenon of Bullshit Jobs\nLine Goes Up â€“ The Problem With NFTs\nPricing Money\n\n\n\nðŸŽµ Music\n\nBlood on the Frets\nWhy 12 notes to the Octave?\nA Guide to Imaginational Anthemâ€™s 10 Volumes of Stirring American Primitive Guitar\nâ€˜A Real Little Taste Of Heavenâ€™: Visionary Guitarist Jack Rose In 11 Songs\nThe Ballad of Geeshie and Elvie\n\n\n\nðŸ¤” Philosophy\n\nWhose Idea Is It, Anyway?\nItâ€™s all bullsh*t! On the relationship between pseudoscience and pseudophilosophy\nThe Normative Status of Logic\nUse and Mention\n\n\n\nðŸ“– Poetry & Short Fiction\n\nMMAcevedo\nSecond Person, Present Tense\nWant Song\nAutopsy\nMiscreant Insects\nTwo-Headed Calf\nThe Revolution Will Not Be Televised\nAll of the Words on a Bottle of Rolling Rock Beer in a Different Order\nTo Explicate Meaning\nKansas, 4 A.M.\n\n\n\nâ° Productivity\n\nProductivity 101: An Introduction to The Pomodoro Technique\nHow a Lazy Bitch like me learned to be Productive\nThe Case Against Collaboration\nEffective Spaced Repetition\nFinish your projects\n\n\n\nðŸ§  Psychology\n\nWhy arenâ€™t smart people happier?\n\n\n\nðŸ‘” Style\n\nHow To Develop Good Taste, Pt. 1\nHow To Develop Good Taste, Pt. 2\nHow To Develop Good Taste, Pt. 3\nArticles of Interest - American Ivy\nThe Most Stylish Man Alive\n\n\n\nðŸ’¾ Technology\n\nWhy Nothing Works Anymore\nSocialismâ€™s DIY Computer\nHow to Take Back the Internet by Choosing the Internet Less Traveled\nThe Old Internet Shows Signs of Quietly Coming Back\nWhy I Still Use RSS\n12ft Ladder\nTinyWow\nWhy We Should Have Markdown Rendered Websites\nThe Bitter Lesson\nThe False Promise of ChatGPT\nWe need more of Richard Stallman, not less"
  },
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "Jesse Onland",
    "section": "",
    "text": "Homeworlds Openings\n\n\n\n\n\nA sojourn on star situations.\n\n\n\n\n\n\nMay 3, 2023\n\n\n\n\n\n\n  \n\n\n\n\nWordle Scores\n\n\n\n\n\nA wealth of word whimsy.\n\n\n\n\n\n\nMar 31, 2023\n\n\n\n\n\n\n  \n\n\n\n\nBooks No One Else Has\n\n\n\n\n\nAn examination of extraordinary editions.\n\n\n\n\n\n\nFeb 4, 2023\n\n\n\n\n\n\n  \n\n\n\n\nCrossword Times\n\n\n\n\n\nA consideration of cruciverbal complexity.\n\n\n\n\n\n\nJan 2, 2023\n\n\n\n\n\n\n  \n\n\n\n\nCoryat Scores\n\n\n\n\n\nThe joy of Jeopardy! judgement.\n\n\n\n\n\n\nOct 17, 2022\n\n\n\n\n\n\n  \n\n\n\n\n(Machine) Learning about Runes\n\n\n\n\n\nAlphabetic algorithm alchemy.\n\n\n\n\n\n\nJun 27, 2022\n\n\n\n\n\n\n  \n\n\n\n\nCities with Nice Weather\n\n\n\n\n\nA meteorological meditation.\n\n\n\n\n\n\nMay 12, 2022\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/city_temperatures/city_temperatures.html",
    "href": "posts/city_temperatures/city_temperatures.html",
    "title": "Cities with Nice Weather",
    "section": "",
    "text": "I live near Toronto. Itâ€™s springtime, and currently about 30 Â°C. In my opinion, Toronto is too hot in the summer and too cold in the winter. Iâ€™d like to know which cities have the least deviation from a tolerable average temperature."
  },
  {
    "objectID": "posts/city_temperatures/city_temperatures.html#tools",
    "href": "posts/city_temperatures/city_temperatures.html#tools",
    "title": "Cities with Nice Weather",
    "section": "Tools",
    "text": "Tools\nThis page was created using Quarto. Iâ€™m using the tidyverse for data wrangling, ggplot2 and ggExtra to plot."
  },
  {
    "objectID": "posts/city_temperatures/city_temperatures.html#data",
    "href": "posts/city_temperatures/city_temperatures.html#data",
    "title": "Cities with Nice Weather",
    "section": "Data",
    "text": "Data\nFirst, I created a CSV file comprising all the information in the Wikpedia article List of cities by average temperature.\n\nread_csv(\"temps.csv\", show_col_types = FALSE) ->\n  city_temps\n\nhead(city_temps)\n\n# A tibble: 6 Ã— 15\n  Country City         Jan   Feb   Mar   Apr   May   Jun   Jul   Aug   Sep   Oct\n  <chr>   <chr>      <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1 Algeria Algiers     11.2  11.9  12.8  14.7  17.7  21.3  24.6  25.2  23.2  19.4\n2 Algeria Tamanrassâ€¦  12.8  15    18.1  22.2  26.1  28.9  28.7  28.2  26.5  22.4\n3 Algeria Reggane     16    18.2  23.1  27.9  32.2  36.4  39.8  38.4  35.5  29.2\n4 Angola  Luanda      26.7  28.5  28.6  28.2  27    23.9  22.1  22.1  23.5  25.2\n5 Benin   Cotonou     27.3  28.5  28.9  28.6  27.8  26.5  25.8  25.6  26    26.7\n6 Benin   Parakou     26.5  28.7  29.6  29    27.5  26.1  25.1  24.7  25    26.1\n# â„¹ 3 more variables: Nov <dbl>, Dec <dbl>, Year <dbl>\n\n\nEach row corresponds to a distinct city. There are two text columns containing each cityâ€™s name and country, twelve numeric columns indicating the â€œaverages of the daily highs and lowsâ€1 for each month, and one additional numeric column containing the same figure for the entire year. The units are degrees Celsius. 455 cities are included in the data.\nWeâ€™ll define the â€œdeviationâ€ mentioned above as the difference between the value recorded for the coldest and hottest months, and the â€œaverageâ€ as the value recorded for the whole year overall.\nWeâ€™ll ignore any other weather characteristics like humidity, rain, wind, diurnal temperature difference, etc.2\n\ncity_temps |>\n  rename_with(tolower) |>\n  rowwise() |>\n  transmute(city,\n            avg = year,\n            range = max(c_across(jan:dec)) - min(c_across(jan:dec))) ->\n  city_temps\n\nhead(city_temps)\n\n# A tibble: 6 Ã— 3\n# Rowwise: \n  city          avg range\n  <chr>       <dbl> <dbl>\n1 Algiers      17.4 14   \n2 Tamanrasset  21.7 16.1 \n3 Reggane      28.3 23.8 \n4 Luanda       25.8  6.5 \n5 Cotonou      27.2  3.30\n6 Parakou      26.8  4.9"
  },
  {
    "objectID": "posts/city_temperatures/city_temperatures.html#summary-statistics",
    "href": "posts/city_temperatures/city_temperatures.html#summary-statistics",
    "title": "Cities with Nice Weather",
    "section": "Summary Statistics",
    "text": "Summary Statistics\nNow we can investigate the distribution of each of our two variables.\nHere are the default summaries:\n\ncity_temps |> \n  select(avg, range) |>\n  summarize()\n\n          N    Mean   SD     Min    Q1 Median    Q3  Max\n1   avg 455   18.00 8.12   -14.4 12.45   18.6 25.65 30.5\n2 range 455   13.75 9.53     0.7  5.65   12.1 21.00 58.1\n\n\nWhich cities correspond to the extremes for each variable?\n\ncity_temps |>\n  filter(\n    avg   %in% (city_temps |> pull(avg)   |> range())  || \n    range %in% (city_temps |> pull(range) |> range())) |>\n  arrange(avg)\n\n# A tibble: 4 Ã— 3\n# Rowwise: \n  city         avg  range\n  <chr>      <dbl>  <dbl>\n1 Gjoa Haven -14.4 42    \n2 Yakutsk     -8.8 58.1  \n3 Honiara     26.5  0.700\n4 Assab       30.5  8.7  \n\n\nLetâ€™s see the values for Toronto as a baseline, and save them for later:\n\ncity_temps |>\n  filter(city == \"Toronto\")\n\n# A tibble: 1 Ã— 3\n# Rowwise: \n  city      avg range\n  <chr>   <dbl> <dbl>\n1 Toronto   9.4    26\n\ncity_temps |>\n  filter(city == \"Toronto\") |>\n  pull(avg) ->\n  toronto_avg\n\ncity_temps |>\n  filter(city == \"Toronto\") |>\n  pull(range) ->\n  toronto_range\n\nBy global standards, Toronto is cool on average, but in keeping with my subjective perception, the deviation from that average over the year is quite large."
  },
  {
    "objectID": "posts/city_temperatures/city_temperatures.html#plots",
    "href": "posts/city_temperatures/city_temperatures.html#plots",
    "title": "Cities with Nice Weather",
    "section": "Plots",
    "text": "Plots\nLetâ€™s look at a scatter plot with marginal histograms:\n\ncity_temps |>\n  ggplot(aes(x = avg, y = range)) +\n  geom_point(alpha = 0.33) +\n  geom_vline(xintercept = toronto_avg,\n             linetype = \"dashed\",\n             alpha = 0.33) +\n  geom_hline(yintercept = toronto_range,\n             linetype = \"dashed\",\n             alpha = 0.33) +\n  labs(title = \"Average Temperature vs Range by City\",\n       x = \"Average Temperature (Â°C)\",\n       y = \"Difference Between Hottest and Coldest Months (Â°C)\") ->\n  plot\n\nplot |>\n  ggMarginal(type = \"histogram\", fill = \"transparent\", size = 10) ->\n  plot\n\nplot\n\n\n\n\nHere Toronto is indicated by the dashed lines.\nWe can see thereâ€™s a negative association between a cityâ€™s average temperature and the range of temperatures experienced there. In particular, thereâ€™s a big cluster of very hot cities which have little difference between their hottest and coldest months.\nTen tropical cities fall into both the hottest decile and the least varying decile:\n\ncity_temps |> \n  filter(range < quantile(city_temps$range, 0.1),\n         avg   > quantile(city_temps$avg,   0.9)) |>\n  select(city)\n\n# A tibble: 10 Ã— 1\n# Rowwise: \n   city         \n   <chr>        \n 1 Lodwar       \n 2 Palembang    \n 3 Pontianak    \n 4 Kuala Lumpur \n 5 MalÃ©         \n 6 Lanka Colombo\n 7 Oranjestad   \n 8 Willemstad   \n 9 Panama City  \n10 Barranquilla \n\n\nWhile these cities see very little temperature variation throughout the year, they are much too hot."
  },
  {
    "objectID": "posts/city_temperatures/city_temperatures.html#zooming-in",
    "href": "posts/city_temperatures/city_temperatures.html#zooming-in",
    "title": "Cities with Nice Weather",
    "section": "Zooming In",
    "text": "Zooming In\nThe area of this plot Iâ€™m most interested in is the vertical slice around Toronto. Letâ€™s see the same plot, including only the cities within one degree of Torontoâ€™s average temperature.3 Weâ€™ll exclude the marginal histograms but add labels to the cities.\n\ncity_temps |>\n  filter(abs(avg - toronto_avg)<=1) |>\n  ggplot(aes(x = avg, y = range, label = city)) +\n  geom_point(alpha = 0.33) +\n  geom_text(size = 4, nudge_x = 0.01, hjust = \"left\") +\n  geom_vline(xintercept = toronto_avg,\n             linetype = \"dashed\",\n             alpha = 0.33) +\n  geom_hline(yintercept = toronto_range,\n             linetype = \"dashed\",\n             alpha = 0.33) +\n  labs(title = \"Average Temperature vs Range by City (Detail 1)\",\n       x = \"Average Temperature (Â°C)\",\n       y = \"Difference Between Hottest and Coldest Months (Â°C)\")\n\n\n\n\nSo it seems that La Paz, Edinburgh, or Dublin might be good options.\nBut which cities are the best? These would be the ones with the smallest range for a given maximum average. Letâ€™s find them."
  },
  {
    "objectID": "posts/city_temperatures/city_temperatures.html#finding-the-cities-with-the-nicest-weather",
    "href": "posts/city_temperatures/city_temperatures.html#finding-the-cities-with-the-nicest-weather",
    "title": "Cities with Nice Weather",
    "section": "Finding the Cities with the Nicest Weather",
    "text": "Finding the Cities with the Nicest Weather\nWe want to know, for each maximum average temperature, the city that has the minimum range of temperatures. These are the cities that form the â€œbottom-left edgeâ€ of our first plot.\nNine cities fit this criterion:\n\ncity_temps |>\n  arrange(avg) |>\n  cbind(city_temps |> arrange(avg) |> pull(range) |> cummin()) |>\n  rename(running_min = 4) |>\n  filter(range == running_min) |>\n  select(city)\n\n        city\n1 Gjoa Haven\n2     Dikson\n3       Nuuk\n4  ReykjavÃ­k\n5    Stanley\n6     La Paz\n7      Cusco\n8     BogotÃ¡\n9    Honiara\n\n\nOf these, the first two have temperatures which are more variable than Toronto, so we can remove them from consideration.\nLetâ€™s plot the final seven candidates:\n\ncity_temps |>\n  arrange(avg) |>\n  cbind(city_temps |> arrange(avg) |> pull(range) |> cummin()) |>\n  rename(running_min = 4) |>\n  filter(range == running_min) |>\n  select(-running_min) |>\n  filter(range <= toronto_range) |>\n  ggplot(aes(x = avg, y = range, label = city)) +\n  geom_point(alpha = 0.33) +\n  geom_text(size = 4, nudge_x = 0.5, hjust = \"left\") +\n  geom_vline(xintercept = toronto_avg,\n             linetype = \"dashed\",\n             alpha = 0.33) +\n  scale_x_continuous(expand = expansion(mult = 0.15)) +\n    labs(title = \"Average Temperature vs Range by City (Detail 2)\",\n         x = \"Average Temperature (Â°C)\",\n         y = \"Difference Between Hottest and Coldest Months (Â°C)\")\n\n\n\n\nAgain we see that La Paz has a similar overall average temperature to Toronto, but much less annual variability. Cusco and BogotÃ¡ are warmer but even less variable.\nReykjavÃ­k and Stanley are colder than Toronto, and while they represent a smaller decrease in variability compared to La Paz, Cusco, and BogotÃ¡, they have the benefit (for me) of being 98%+ English-speaking.\nNuuk and Honiara are right out."
  },
  {
    "objectID": "posts/city_temperatures/city_temperatures.html#next-steps",
    "href": "posts/city_temperatures/city_temperatures.html#next-steps",
    "title": "Cities with Nice Weather",
    "section": "Next Steps",
    "text": "Next Steps\nIt would be interesting to use detailed time series for each city and a utility function on temperatures (perhaps including wind chill and humidex) to determine which cities are truly mean-variance optimal.\nOf course, one should probably not choose a place to live based solely on the weather."
  },
  {
    "objectID": "posts/machine_learning_about_runes/machine_learning_about_runes.html",
    "href": "posts/machine_learning_about_runes/machine_learning_about_runes.html",
    "title": "(Machine) Learning about Runes",
    "section": "",
    "text": "Today weâ€™ll learn about an ancient Germanic writing system, clean up some messy data, engineer a couple of simple features, and see if we can find a way to predict the age of some historical artifacts without having to pay for a fancy-schmancy archaeology degree. Along the way, weâ€™ll get a little overview of the tidyverse and tidymodels approaches to data analysis and modeling in R.\n\n\nA rune is a letter from any of a handful of closely-related alphabets used by Germanic peoples primarily from around the 3rd to the 13th centuries CE. Like the Latin alphabet used to write the Germanic languages today, they derive from an ancient form of the Greek alphabet.1 These alphabets are sometimes called â€œfutharkâ€ (or â€œfuthorcâ€, â€œfuÃ¾Ä…rkâ€, etc.) after first few letters in their canonical order.2\nThe main runic alphabets are3:\n\n\n\n\n\n\n\n\n\nName\nMain Language(s)\nEra (c.Â CE)\nLetters\n\n\n\n\nElder Futhark\nProto-Germanic, Proto-Norse\n1stâ€“8th\náš  áš¢ áš¦ áš¨ áš± áš² áš· áš¹ ášº áš¾ á› á›ƒ á›ˆ á›‡ á›‰ á›Š á› á›’ á›– á›— á›š\n\n\nAnglo-Frisian Futhorc\nOld Frisian, Old English\n5thâ€“11th\náš  áš¢ áš¦ áš© áš± áš³ áš· áš¹ áš» áš¾ á› á›¡ á›‡ á›ˆ á›‰ á›‹ á› á›’ á›– á›— á›š á› á›Ÿ á›ž ášª áš« á›  áš£\n\n\nYounger Futhark\nOld Norse\n8thâ€“12th\náš  áš¢ áš¦ áš¬ áš± áš´ áš¼ áš¾ á› á›… á›¦ á›‹ á› á›’ á›˜ á›š\n\n\nMedieval Runes\nOld Icelandic, Old Swedish\n12thâ€“17th\náš  áš¢ áš¦ áš® áš± áš´ áš¼ áš¿ á› á›† á›Œ á› á›’ á›˜ á›š á›¦\n\n\n\nMagical incantations were sometimes written in runes, but despite what such august institutions as the gift shop of the National Museum of Iceland would have you believe, thereâ€™s no evidence that each runic letter had a specific symbolic meaning.4 Neither is there much evidence that they were used in divination. These alphabets were used mainly for mundane purposes such as inscribing an object with its owner or creatorâ€™s name, and for memorializing the dead on gravestones. Nevertheless, in recent times these alphabets have become an element in various kinds of New Age mysticism, neo-pagan religions, and unsavoury political movements.\n\n\n\nRuneS-DB is a database of artifacts bearing runic writing compiled from a variety of sources as part of RuneS, an overarching project to study these writing systems. Itâ€™s available from the RuneS projectâ€™s website.\n\nThe rights to the data are held by the GÃ¶ttingen Academy of Sciences and Humanities and are subject to the CC-BY- SA law. The RuneS research units GÃ¶ttingen, EichstÃ¤tt-MÃ¼nchen and Kiel were involved in the generation of the data. RuneS-DB contains data from the Kiel Runenprojekt, the Danish database runer.ku.dk and the Samnordisk runtextdatabas/Rundata accessible under the Open Database License (ODbL). Please also note the additional information on other origin of the data provided under the label sources.\n\nRuneS provides a tool on their website to query the database, but itâ€™s pretty clunky. Instead, weâ€™ll use R to see if we can learn anything interesting.\n\n\n\nWeâ€™ll use the tidyverse collection of packages for manipulating and visualizing our data and the tidymodels packages to quickly define, train, and compare a few machine learning models. These packages â€œshare an underlying design philosophy, grammar, and data structuresâ€ rooted in the â€œtidy dataâ€ principles originally espoused by Hadley Wickham.\nThis document was lovingly hand-crafted in artisanal, farm-to-table, GMO-free Quarto."
  },
  {
    "objectID": "posts/machine_learning_about_runes/machine_learning_about_runes.html#reading-and-cleaning-the-data",
    "href": "posts/machine_learning_about_runes/machine_learning_about_runes.html#reading-and-cleaning-the-data",
    "title": "(Machine) Learning about Runes",
    "section": "Reading and Cleaning the Data",
    "text": "Reading and Cleaning the Data\n\nReading the File\nThe file we obtain from the RuneS website is tab-separated, contains three lines of preamble, and uses a hyphen to indicate missing data. Providing this information to readrâ€™s read_delim will produce a tibble (i.e., a fancy data frame, which is in turn a fancy matrix) that we can begin to manipulate.\n\n# read the file\nread_delim(file = \"runes_data.csv\",\n           delim = \";\",\n           skip = 3,\n           na = \"-\",\n           show_col_types = FALSE) ->\n  # save to a dataframe\n  runes_data\n\n\n\nThe Vimose Comb\nOne artifact weâ€™d expect to find in RuneS-DB is the Vimose comb, which bears whatâ€™s considered to be the oldest known datable5 runic inscription. dplyrâ€™s filter function and stringrâ€™s str_detect let us filter the data to show only rows where value in the column of inscription names matches â€œVimose combâ€.6\n\nrunes_data |>\n  filter(str_detect(rs_short_inscr_name, pattern = \"Vimose comb\")) |>\n  kbl() |>\n  scroll_box(width = \"51.75%\")\n\n\n\n \n  \n    Findno \n    rs_short_inscr_name \n    rs_fundort \n    rs_short_storage \n    rs_extdat \n    rs_short_dat_art \n    rs_short_context \n    rs_objklasse \n    rs_objtyp \n    rs_short_obj_complete \n    rs_short_matklasse \n    rs_mat \n    rs_short_obj_state \n    rs_runenreihe \n    rs_short_museum \n    rs_short_ins_complete \n    rs_translat \n    rs_translit \n    rs_short_ins_state \n    rs_short_markings \n    rs_short_transkript \n    rs_namen \n    rs_fundjahr \n    rs_short_gemeinde \n    rs_short_bezirk \n    rs_short_landschaft \n    rs_short_land \n    rs_short_invnr \n    rs_short_kategorie \n    rs_short_sigils \n    rs_traeger \n  \n \n\n  \n    20 \n    Vimose comb \n    Vimose \n    Museum \n    140-160 \n    arch. \n    deposit find \n    tool/implement \n    personal hygiene \n    yes \n    bone/horn \n    antler \n    good \n    older fuÃ¾ark \n    Nationalmuseet \n    yes \n    Harja. \n    harja | \n    good \n    nein \n    NA \n    Vimose-kam \n    1865 \n    Allese Sogn \n    Odense Amt \n    Fyn \n    DK \n    22657 \n    run. \n    Fyn 19 \n    comb \n  \n\n\n\n\n\nSo we can see that this object was found in Vimose, currently resides in a museum, has been dated to 140-160 CE, is a personal hygiene tool made of antler, says â€œharjaâ€ (ášºáš¨áš±á›ƒáš¨), etc.\n\n\nDiagnosing\nOne way to quantify the messiness of a data set is to calculate the count and proportion of missing and unique values in each column. dlookrâ€™s diagnose does this.\n\nrunes_data |> \n  diagnose() |>\n  kbl() |>\n  scroll_box(width = \"51.75%\")\n\n\n\n \n  \n    variables \n    types \n    missing_count \n    missing_percent \n    unique_count \n    unique_rate \n  \n \n\n  \n    Findno \n    numeric \n    0 \n    0.0000000 \n    8281 \n    1.0000000 \n  \n  \n    rs_short_inscr_name \n    character \n    7 \n    0.0845309 \n    5457 \n    0.6589784 \n  \n  \n    rs_fundort \n    character \n    34 \n    0.4105784 \n    3156 \n    0.3811134 \n  \n  \n    rs_short_storage \n    character \n    0 \n    0.0000000 \n    1723 \n    0.2080667 \n  \n  \n    rs_extdat \n    character \n    6 \n    0.0724550 \n    573 \n    0.0691945 \n  \n  \n    rs_short_dat_art \n    character \n    1988 \n    24.0067625 \n    19 \n    0.0022944 \n  \n  \n    rs_short_context \n    character \n    5240 \n    63.2773820 \n    21 \n    0.0025359 \n  \n  \n    rs_objklasse \n    character \n    33 \n    0.3985026 \n    13 \n    0.0015699 \n  \n  \n    rs_objtyp \n    character \n    1452 \n    17.5341142 \n    45 \n    0.0054341 \n  \n  \n    rs_short_obj_complete \n    character \n    1873 \n    22.6180413 \n    4 \n    0.0004830 \n  \n  \n    rs_short_matklasse \n    character \n    43 \n    0.5192610 \n    11 \n    0.0013283 \n  \n  \n    rs_mat \n    character \n    3550 \n    42.8692187 \n    119 \n    0.0143702 \n  \n  \n    rs_short_obj_state \n    character \n    1970 \n    23.7893974 \n    6 \n    0.0007246 \n  \n  \n    rs_runenreihe \n    character \n    463 \n    5.5911122 \n    12 \n    0.0014491 \n  \n  \n    rs_short_museum \n    character \n    4382 \n    52.9163145 \n    291 \n    0.0351407 \n  \n  \n    rs_short_ins_complete \n    character \n    1259 \n    15.2034778 \n    4 \n    0.0004830 \n  \n  \n    rs_translat \n    character \n    698 \n    8.4289337 \n    5592 \n    0.6752808 \n  \n  \n    rs_translit \n    character \n    91 \n    1.0989011 \n    7482 \n    0.9035141 \n  \n  \n    rs_short_ins_state \n    character \n    1371 \n    16.5559715 \n    6 \n    0.0007246 \n  \n  \n    rs_short_markings \n    character \n    2676 \n    32.3149378 \n    3 \n    0.0003623 \n  \n  \n    rs_short_transkript \n    character \n    1090 \n    13.1626615 \n    5536 \n    0.6685183 \n  \n  \n    rs_namen \n    character \n    5662 \n    68.3733849 \n    1554 \n    0.1876585 \n  \n  \n    rs_fundjahr \n    character \n    4895 \n    59.1112185 \n    700 \n    0.0845309 \n  \n  \n    rs_short_gemeinde \n    character \n    1435 \n    17.3288250 \n    1682 \n    0.2031156 \n  \n  \n    rs_short_bezirk \n    character \n    3287 \n    39.6932738 \n    406 \n    0.0490279 \n  \n  \n    rs_short_landschaft \n    character \n    1384 \n    16.7129574 \n    124 \n    0.0149740 \n  \n  \n    rs_short_land \n    character \n    48 \n    0.5796401 \n    28 \n    0.0033812 \n  \n  \n    rs_short_invnr \n    character \n    4709 \n    56.8651129 \n    2524 \n    0.3047941 \n  \n  \n    rs_short_kategorie \n    character \n    1227 \n    14.8170511 \n    15 \n    0.0018114 \n  \n  \n    rs_short_sigils \n    character \n    125 \n    1.5094795 \n    8129 \n    0.9816447 \n  \n  \n    rs_traeger \n    character \n    8 \n    0.0966067 \n    416 \n    0.0502355 \n  \n\n\n\n\n\nUnfortunately, RuneS-DB is a bit of a mess. Because itâ€™s amalgamated from many sources, information is coded inconsistently. A mix of languages are used, including in the column names. Getting this data set clean enough to start visualizing it is easy enough using dplyr functions like rename(), separate(), and mutate().\nThe first step is to make the column names more informative and get rid of the weird â€œrs_â€ and â€œrs_short_â€ prefixes.\n\nrunes_data |>\n  # rename the columns\n  rename(\n    find_number          = Findno,\n    inscription_name     = rs_short_inscr_name,\n    location             = rs_short_storage,\n    date                 = rs_extdat,\n    dating_method        = rs_short_dat_art,\n    context              = rs_short_context,\n    findspot             = rs_fundort,\n    object_class         = rs_objklasse,\n    object_type          = rs_objtyp,\n    object_complete      = rs_short_obj_complete,\n    material_class       = rs_short_matklasse,\n    material             = rs_mat,\n    object_state         = rs_short_obj_state,\n    writing_system       = rs_runenreihe,\n    museum               = rs_short_museum,\n    inscription_complete = rs_short_ins_complete,\n    translation          = rs_translat,\n    transliteration      = rs_translit,\n    inscription_state    = rs_short_ins_state,\n    markings             = rs_short_markings,\n    transcription        = rs_short_transkript,\n    names                = rs_namen,\n    find_year            = rs_fundjahr,\n    community            = rs_short_gemeinde,\n    district             = rs_short_bezirk,\n    region               = rs_short_landschaft,\n    country              = rs_short_land,\n    inventory_number     = rs_short_invnr,\n    category             = rs_short_kategorie,\n    shelf_marks          = rs_short_sigils,\n    carrier              = rs_traeger\n  ) ->\n  # update the dataframe\n  runes_data\n\nNext weâ€™ll separate the location column into two columns, one with the general category and the other with the rest of the information. Weâ€™ll also create separate columns for the lower and upper bounds of each date, then convert this into a midpoint and a range.\n\nrunes_data |>\n  # separate location category and detail\n  separate(\n    location,\n    into = c(\"location_class\", \"location_detail\"),\n    sep = \":\",\n    extra = \"merge\") |>\n  # separate the date column into lower and upper bounds\n  separate(date, into = c(\"date_lower\", \"date_upper\")) |>\n  mutate(\n    # set dates to NA for undated objects\n    across(starts_with(\"date\"), ~ na_if(., \"0\")),\n    # treat the dates as numbers\n    across(starts_with(\"date\"), ~ as.numeric(.)),\n    # get the middle of each date range\n    date = (date_lower + date_upper) / 2,\n    # get the range of each date\n    date_range = date_upper - date_lower) |>\n  # discard the date bounds\n  select(-c(date_upper, date_lower)) ->\n  # update the dataframe again\n  runes_data\n\nNext letâ€™s convert RuneS-DBâ€™s somewhat idiosyncratic country codes into human-readable names. While weâ€™re at it, weâ€™ll collapse the rarest ones into a â€œRest of Worldâ€ category.\n\nrunes_data |>\n  mutate(\n    country = recode(\n      country,\n      \"S\"  = \"Sweden\",\n      \"N\"  = \"Norway\",\n      \"DK\" = \"Denmark\",\n      \"IS\" = \"Iceland\",\n      \"GB\" = \"Great Britain\",\n      \"D\"  = \"Germany\",\n      \"KN\" = \"Greenland\",\n      .default = \"Rest of World\")) ->\n  runes_data\n\nFinally some miscellaneous re-encoding.\n\nrunes_data |>\n  mutate(\n    # treat the ID numbers as strings\n    find_number = as.character(find_number),\n    # eliminate excess whitespace\n    across(where(is.character), str_squish),\n    # translate the markings column into English\n    markings = recode(markings, \"ja\" = \"yes\", \"nein\" = \"no\"),\n    # replace cross symbol\n    across(where(is.character), ~ recode(., \"â€ \" = \"lost/destroyed\")),\n    # replace \"rune stick/rÃºnakefli\", shorten \"weapon/weapon accessories\"\n    object_class = recode(\n      iconv(object_class, to = 'ASCII//TRANSLIT'),\n      \"rune stick/runakefli\" = \"rune stick\",\n      \"weapon/weapon accessories\" = \"weapon/accessory\"),\n    # make \"Museum\" lowercase for consistency\n    location_class = recode(location_class, \"Museum\" = \"museum\"),\n    # combine parchment and paper into a single material class\n    material_class = recode(\n      material_class,\n      \"parchment; paper\" = \"parchment/paper\",\n      \"parchment\" = \"parchment/paper\",\n      \"paper\" = \"parchment/paper\"),\n    # give the writing systems friendlier names, combine medieval and post-Reformation runes as \"manuscript runes\"\n    writing_system = recode(\n      iconv(writing_system, to = 'ASCII//TRANSLIT'),\n      \"older fu?ark\" = \"elder futhark\",\n      \"younger fu?ark\" = \"younger futhark\",\n      \"fu?orc\" = \"anglo-frisian futhorc\",\n      \"post-Reformation runes\" = \"manuscript runes\",\n      \"medieval runes\" = \"manuscript runes\",\n      .default = \"mixed/unknown\")) ->\n  runes_data\n\nThereâ€™s more cleaning we could do, but this is enough for now."
  },
  {
    "objectID": "posts/machine_learning_about_runes/machine_learning_about_runes.html#exploratory-data-analysis",
    "href": "posts/machine_learning_about_runes/machine_learning_about_runes.html#exploratory-data-analysis",
    "title": "(Machine) Learning about Runes",
    "section": "Exploratory Data Analysis",
    "text": "Exploratory Data Analysis\n\nrunes_data |>\n  drop_na(object_class, material_class) |>\n  group_by(object_class, material_class) |>\n  summarise(count = n()) |>\n  ggplot(aes(x = object_class, y = material_class, size = count)) +\n  geom_point(shape = 21, fill = \"#595959\") +\n  coord_flip() +\n  scale_size(range = c(0, 10)) +\n  guides(size = \"none\") +\n  labs(\n    title = \"Runic Artifacts by Object and Material Class\",\n    x = \"Object Class\",\n    y = \"Material Class\")\n\n\n\n\n\n\n\n\nNearly half of the artifacts in RuneS-DB are stones7, which it turns out are always made of stone! Likewise, coins and bracteates8 are always made of metal, and rune sticks are always made of wood. Tools, edifices, â€œinventoryâ€ (mostly furniture), and â€œother objectsâ€ all seem to come in a variety of materials.\nWhere is this stuff typically found?\n\nrunes_data |>\n  # discard artifacts missing country information\n  drop_na(country) |>\n  ggplot(aes(fct_infreq(country))) +\n  geom_bar() +\n  geom_hline(yintercept = seq(0, 4000, 1000), color = \"white\") +\n  coord_flip() +\n  labs(\n    title = \"Runic Objects by Country\",\n    x = \"Country of Discovery\",\n    y = \"Number of Objects\")\n\n\n\n\n\n\n\n\nRight. Scandinavia, mostly.\nOne last exploratory graphic. How old is this stuff?\n\nrunes_data |>\n  # discard undated objects\n  drop_na(date) |>\n  ggplot(aes(date)) +\n  # bin into centuries\n  geom_histogram(\n    fill = \"#595959\", \n    color = \"white\", \n    breaks = seq(1, 2022, by=100)) +\n  geom_hline(yintercept = seq(0, 3000, 1000), color = \"white\") +\n  scale_x_continuous(breaks = seq(0, 2000, by = 100)) +\n  labs(\n    title = \"Number of Runic Objects by Century\",\n    x = \"Year of Manufacture\",\n    y = \"Number of Objects\")\n\n\n\n\n\n\n\n\nThis histogram has a huge spike at the 10th century. Upon cursory investigation, this seems to be because the data set contains many rune stones with dated to the rather wide range of â€œ725-1100â€, i.e.Â the Viking Age. Obviously this data set is not random sample of all runic objects ever produced; some things are more likely to survive and be cataloged than others. The smaller spike at the 13th century seems to be more organic."
  },
  {
    "objectID": "posts/machine_learning_about_runes/machine_learning_about_runes.html#feature-engineering",
    "href": "posts/machine_learning_about_runes/machine_learning_about_runes.html#feature-engineering",
    "title": "(Machine) Learning about Runes",
    "section": "Feature Engineering",
    "text": "Feature Engineering\nSuppose youâ€™re lost in the woods in northwestern Europe9 and stumble upon some runes. Is there some rule you can use to estimate when they were carved (or written)?\nFirst, we need to consider what features of the object youâ€™d be able to determine. I think these are all reasonable:\n\nobject class (stone, coin, etc.)\nmaterial class (stone, metal, wood, etc.)\ncountry\nwriting system (elder futhark, anglo-frisian futhorc, etc.)\nlength of the inscription\nwhether the inscription contains an abecedarium; something like â€œfuÃ¾arkgwâ€¦â€ or â€œabcdefghâ€¦â€\nwhether the inscription seems to contain any of a few common words or morphemes\n\nThe first four of these features are already present in our data frame. Weâ€™ll have to â€œengineerâ€ the others.\nUnfortunately, the transliterations in RuneS-DB are very inconsistently encoded, but we can still get an approximate length of each inscription by converting the transliteration to ASCII10 and counting the number of resulting alphanumeric characters11. Itâ€™s too bad the database doesnâ€™t simply use the runic characters included in Unicode, but perhaps that wouldnâ€™t be sufficient to encode parts of the inscriptions which are unclear, damaged, combined into ligatures (so-called â€œbind runesâ€), etc.\n\nrunes_data |>\n  mutate(\n    inscription_length =\n      transliteration |>\n      # convert to ASCII\n      iconv(to = \"ASCII//TRANSLIT\") |>\n      # count alphanumeric characters\n      str_count(\"[[:lower:]\\\\?]\")) ->\n  runes_data\n\nWe can identify abecedaria by slightly re-encoding the â€œcategoryâ€ column.\n\nrunes_data |>\n  mutate(\n    abecedarium = case_when(\n      str_detect(category, \"alphabet\") ~ \"abc\",\n      str_detect(category, \"row\") ~ \"futh\",\n      TRUE ~ \"no\")) ->\n  runes_data\n\nAnother feature we can derive from the inscription is what kind of spacing is used between words.\n\nrunes_data |>\n  mutate(\n    spaces = case_when(\n      str_detect(transliteration, \" [Ã·\\\\*\\\\+] \") ~ \"crosses/stars\",\n      str_detect(transliteration, \" Ã— \") ~ \"crosses/stars\",\n      str_detect(transliteration, \" [Ëˆ\\\\.] \") ~ \"single dots\",\n      str_detect(transliteration, \" : \") ~ \"double dots\",\n      TRUE ~ \"none/other\")) ->\n  runes_data\n\nFinally letâ€™s encode the presence or absence of a few of the most common words/morphemes.\n\nrunes_data |>\n  mutate(\n    sin_sun_syn = str_detect(transliteration, \"sin|sun|syn\"),\n    auk_uk_ok   = str_detect(transliteration, \"auk|uk|ok\"),\n    at          = str_detect(transliteration, \"at\"),\n#   fathur      = str_detect(transliteration, \"faÃ¾ur\"),\n    stain_stin  = str_detect(transliteration, \"stain|stin|stÓ•in\"),\n    lit         = str_detect(transliteration, \"lit\"),\n    across(sin_sun_syn:lit, as.numeric)) ->\n  runes_data\n\nIs this enough information to be able to predict the age of a runic inscription with any accuracy? Letâ€™s try fitting a few different models using different approaches."
  },
  {
    "objectID": "posts/machine_learning_about_runes/machine_learning_about_runes.html#model-fitting",
    "href": "posts/machine_learning_about_runes/machine_learning_about_runes.html#model-fitting",
    "title": "(Machine) Learning about Runes",
    "section": "Model Fitting",
    "text": "Model Fitting\n\nTest/Training Data Split\nFirst weâ€™ll split the data into a training and a test set, then create cross-validation folds from training data to help estimate model performance.\n\nrunes_data |>\n  # keep just the features we want to predict from\n  select(\n    object_class, \n    material_class, \n    country, \n    writing_system, \n    inscription_length,\n    abecedarium,\n    spaces,\n    sin_sun_syn:lit,\n    date) |>\n  # discard objects with missing data\n  na.omit() ->\n  runes_data\n\n# split into training (75%) and test (25%) sets, stratified by date\ninitial_split(\n    data = runes_data, \n    prop = 0.75, \n    strata = date) ->\n  split\n\n# store a copy of each set\ntraining(split) -> train\ntesting(split) -> test\n\n# create 10 cross-validation folds\nvfold_cv(train) -> folds\n\nThe tidymodels framework provides a unified interface to various model-specific packages, as well as convenient functions for defining, fitting, tuning, and comparing many combinations of data pre-processing recipes and model specifications.\n\nIn parsnip, the model type differentiates basic modeling approaches, such as random forests, logistic regression, linear support vector machines, etc.; the mode denotes in what kind of modeling context it will be used (most commonly, classification or regression); and the computational engine indicates how the model is fit, such as with a specific R package implementation or even methods outside of R like Keras or Stan.\n\n\n\nPre-Processing Recipe\nNext weâ€™ll define two pre-processing recipes. In both cases weâ€™ll normalize our numeric predictor. Some model types require categorical predictors to be dummy-encoded, while others can exhibit better performance with categorical predictors left as-is. Weâ€™ll try both ways.\n\n# create a pre-processing recipe\nrecipe(runes_data) |>\n  update_role(date, new_role = \"outcome\") |>\n  update_role(1:(ncol(runes_data) - 1), new_role = \"predictor\") |>\n  # normalize the numeric feature\n  step_normalize(all_numeric_predictors()) |>\n  # dummy encode the categorical features\n  step_dummy(all_nominal_predictors()) ->\n  runes_recipe\n\n\n\nBaseline\nNow we can define our models. First letâ€™s â€œfitâ€ the null model, which consists of just always guessing the mean date value from the training set. Itâ€™s straightforward to simply calculate the appropriate RMSE estimate in this case, but for illustrative purposes weâ€™ll use cross-validation anyway. It doesnâ€™t matter which recipe we use since the null model ignores the predictors anyway.\n\nnull_model() |>\n  set_engine(\"parsnip\") |>\n  set_mode(\"regression\") ->\n  null_spec\n\nworkflow() |>\n  add_model(null_spec) |>\n  add_recipe(runes_recipe) |>\n  fit_resamples(resamples = folds, metrics = metric_set(rmse)) |>\n  collect_metrics() |>\n  pull(mean)\n\n[1] 311.4979\n\n\nThe null modelâ€™s prediction is, in a certain sense, off by more than three centuries on average. Surely we can do better than that.\n\n\nThe Bias-Variance Trade-off\n\n\nModel Specification\nWeâ€™ll try six more kinds of model. Each comes with some hyperparameters which control the bias-variance tradeoff, the step size for gradient descent, etc. We can leave tune() as a placeholder for these values when creating the model specifications. When we fit the models, weâ€™ll try 10 combinations of hyperparameter values for each model type, and keep only the best ones.\nA linear model assumes the outcome is a linear function of the predictors and finds the best coefficient to assign to each. Linear models are inflexible, and so tend to suffer from bias (unless the underlying relationship really is approximately linear), but they tend to have lower variance than more flexible model types, since their outputs are not too sensitive to small changes in their inputs. The penalty and mixture hyperparameters here control how much L1 (LASSO) and/or L2 (ridge) regularization to apply. Regularization penalizes more complex models in order to prevent overfitting.\n\nlinear_reg(\n  engine  = \"glmnet\",\n  penalty = tune(),\n  mixture = tune()) ->\n  linear_spec\n\nA decision tree is essentially a flowchart, with each split corresponding to a rule in the form of an â€œif/thenâ€ condition on a predictor. The idea is to find the splits which best separate the outcome. Predictions are produced by taking the average outcome among the training data belonging to the relevant terminal node of the tree. tree_depth specifies the maximum depth of the tree; without some maximum, the training data could be completely interpolated (or â€œmemorizedâ€), an extreme form of overfitting. cost_complexity controls how well a split must separate its subset of the training data in order to be considered, and min_n controls how much training data must belong to a node in order to justify any further splitting.\n\ndecision_tree(engine     = \"partykit\",\n              tree_depth = tune(),\n              min_n      = tune()) ->\n  decision_tree_spec\n\nNearest neighbours models predict that the value of the outcome for a test data point will be some kind of weighted average of that pointâ€™s nearest neighbours in the training data. neighbors controls the number of neighbours to consider and the other hyperparameters specify the precise notions of â€œweighted averageâ€ and â€œnearestâ€ to use.\n\nnearest_neighbor(engine      = \"kknn\",\n                 neighbors   = tune(),\n                 weight_func = tune(),\n                 dist_power  = tune()) ->\n  nearest_neighbours_spec\n\nBoosted tree ensembles are a very popular machine learning approach involving fitting many small decision trees, each of which is optimized to improve the predictions obtained by combining the preceding trees. This model type inherents the hyperparameters involved in fitting decision trees, plus additional hyperparameters specifying the number of trees to use, the proportion of training data and number of predictors to consider at each step during fitting, as well as how much weight to initially apply to each new tree.\n\nboost_tree(engine         = \"xgboost\",\n           trees          = 1000,\n           tree_depth     = tune(),\n           min_n          = tune(),\n           loss_reduction = tune(),\n           sample_size    = tune(),\n           mtry           = tune(),\n           learn_rate     = tune()) ->\n  boosted_trees_spec\n\nSome approaches combine multiple other types of models. Cubist involves a tree ensemble with linear models fit on each tree node, a boosting-like procedure, and a final nearest-neighbours-based adjustment.\n\ncubist_rules(engine = \"Cubist\",\n             committees = tune(),\n             neighbors = tune()) ->\n  cubist_spec\n\n\n\nModel Fitting\nIn tidymodels, a â€œworkflowâ€ is an object which bundles together a model specification together with any associated pre-processing recipes, hyperparameter values, and/or evaluation results. workflow_set and workflow_map allow us to tune all of our model specifications as a batch.\n\n# combine the model specifications in a list\nlist(linear        = linear_spec,\n     tree          = decision_tree_spec,\n     nn            = nearest_neighbours_spec,\n     boosted_trees = boosted_trees_spec,\n     cubist        = cubist_spec) ->\n  runes_model_specs\n\n# set the prediction mode of each engine to \"regression\"\nrunes_model_specs |>\n  map(~set_mode(., \"regression\")) ->\n  runes_model_specs\n\n# combine pre-processing recipe and model specifications into a workflow set\nworkflow_set(preproc = list(recipe = runes_recipe),\n             models = runes_model_specs) ->\n  runes_workflow_set\n\nrunes_workflow_set |>\n  # for each model specification, try ten combinations of tuning parameters\n  # and estimate rmse using cross-validation\n  workflow_map(\"tune_grid\",\n               resamples = folds,\n               grid = 10,\n               metrics = metric_set(rmse)) ->\n  # update the workflow set with the results\n  runes_workflow_set\n\n\n\nPerformance Comparison\nNow our workflow set contains ten fit models per model type for each of ten hyperparameter combinations. We can extract the best version of each model type and plot the cross-validated performance estimates.\n\n# plot the rmse estimate from the best iteration of each type of model\nrank_results(runes_workflow_set, select_best = TRUE) |>\n  group_by(model) |>\n  slice_max(mean) |>\n  select(mean, std_err, model) |>\n  rename(rmse_mean = mean, rmse_std_err = std_err) |>\n  ggplot(aes(x = fct_reorder(model, -desc(rmse_mean)), y = rmse_mean)) +\n  geom_errorbar(aes(ymin = rmse_mean - rmse_std_err,\n                    ymax = rmse_mean + rmse_std_err),\n                width = 0.1,\n                size = 1.5,\n                color = \"#595959\") +\n  labs(x = \"Model Type\",\n       y = \"Estimated RMSE\",\n       title = \"Estimated RMSE for Best Model of Each Type\")\n\n\n\n\n\n\n\n\nIt appears that Cubist and boosted trees models work best for these data. Letâ€™s finalize a Cubist model by re-fitting the best one on the entire training set, and seeing how well it predicts the age of artifacts in the test set.\n\nrunes_workflow_set |>\n  # get the cubist workflow\n  extract_workflow(\"recipe_cubist\") |>\n  # get the best cubist hyperparameters and apply them to the workflow\n  finalize_workflow(\n    runes_workflow_set |>\n      extract_workflow_set_result(\"recipe_cubist\") |>\n      select_best(metric = \"rmse\")) |>\n  # fit on the entire training set\n  last_fit(split, metrics = metric_set(rmse)) ->\n  final_cubist\n\n\n\nThe Performance-Explainability Trade-off\nUnfortunately, our finalized Cubist model is useless. Since weâ€™re lost in the woods, we canâ€™t actually compute a prediction involving a complicated collection of trees of linear models with hundreds or thousands of coefficients and weights in total.\nCan we find a simple decision tree with comparable performance by trying more hyperparameter combinations? Letâ€™s set tree_depth to 3, find good values for the other hyperparameters, then finalize and evaluate the resulting decision tree model.\n\ndecision_tree_spec |>\n  set_args(tree_depth = 3) |>\n  set_mode(\"regression\") ->\n  decision_tree_spec\n\nworkflow() |>\n  add_model(decision_tree_spec) |>\n  add_recipe(runes_recipe) |>\n  # try 100 combinations of cost_complexity and min_n\n  tune_grid(resamples = folds, metrics = metric_set(rmse), grid = 100) |>\n  # keep the best ones\n  select_best(metric = \"rmse\") |>\n  # plug them back into the model specification\n  finalize_workflow(\n    workflow() |> \n      add_model(decision_tree_spec) |>\n      add_recipe(runes_recipe),\n    parameters = _) |>\n  # fit on the entire training set\n  last_fit(split, metrics = metric_set(rmse)) ->\n  small_tree\n\nNow we have two finalized models: a Cubist model and a small decision tree. The most obvious way to compare them would be to inspect their performance, but we can also use the vip package to extract the number of features used by each model, giving us a way to compare their relative complexity as well.\n\ndata.frame(\n  model    = c(\"Cubist\", \"Small Decision Tree\"),\n  rmse     = c(final_cubist |> collect_metrics() |> pull(.estimate), \n               small_tree   |> collect_metrics() |> pull(.estimate)),\n  features = c(final_cubist |> extract_fit_engine() |> vi() |> filter(Importance > 0) |> nrow(),\n               small_tree   |> extract_fit_engine() |> vi() |> filter(Importance > 0) |> nrow())) |>\n  kbl() |>\n  scroll_box(width = \"51.75%\")\n\n\n\n \n  \n    model \n    rmse \n    features \n  \n \n\n  \n    Cubist \n    109.7088 \n    38 \n  \n  \n    Small Decision Tree \n    131.1698 \n    7 \n  \n\n\n\n\n\nThe small decision treeâ€™s predictions are about 16% worse than the best Cubist model we could find. On the other hand, itâ€™s much simpler. While the Cubist model uses essentially all of the information we provided to it, since we constrained our decision tree to three levels, it can use only a maximum of seven features.12 Although the more complicated Cubist performs well, itâ€™s difficult to explain exactly why, or what the role of each feature is in generating predictions. This illustrates the performance-explainability trade-off.\nOur small tree model is simple enough to write on an index card and keep with us when venturing out into the forests of rural Scandinavia. Here it is:\n\nsmall_tree |>\n  extract_fit_engine() |>\n  as.simpleparty() |>\n  plot(\n    ip_args = list(pval = FALSE, id = FALSE),\n    tp_args = list(\n      id = FALSE, \n      FUN = function(node){round(node$prediction[1])}))"
  },
  {
    "objectID": "posts/machine_learning_about_runes/machine_learning_about_runes.html#conclusion",
    "href": "posts/machine_learning_about_runes/machine_learning_about_runes.html#conclusion",
    "title": "(Machine) Learning about Runes",
    "section": "Conclusion",
    "text": "Conclusion\nIf you can foresee yourself desperately needing to know the approximate age of a runic inscription, I recommend you write down the decision tree above and keep it in your pocket. That, or always bring a licensed and qualified runologist13 with you."
  },
  {
    "objectID": "posts/machine_learning_about_runes/machine_learning_about_runes.html#references",
    "href": "posts/machine_learning_about_runes/machine_learning_about_runes.html#references",
    "title": "(Machine) Learning about Runes",
    "section": "References",
    "text": "References\n\nRunes\n\nRunes and their Origin: Denmark and Elsewhere (Moltke, 1985)\nRunes (Findell, 2014)\nFuthark Journal\n\n\n\nStatistical Inference and Machine Learning\n\nElements of Statistical Learning (Friedman, et al., 2001)\n\n\n\nData Science in R\n\nTidy Data (Wickham, 2014)\nR for Data Science (Grolemund & Wickham, 2016)\nTidy Modeling with R (Kuhn & Silge, forthcoming)"
  },
  {
    "objectID": "posts/coryat_scores/coryat_scores.html",
    "href": "posts/coryat_scores/coryat_scores.html",
    "title": "Coryat Scores",
    "section": "",
    "text": "The Coryat score is a way of measuring oneâ€™s performance when playing along with Jeopardy! at home. It is named after musician, philosopher of physics, and two-day Jeopardy! champion Karl Coryat.\nA playerâ€™s Coryat score is the total value of clues answered correctly, minus that of those answered incorrectly, counting correctly-answered Daily Doubles according to their board position and ignoring Final Jeopardy! and any incorrectly-answered Daily Doubles.\nThus the Coryat score is a measure of oneâ€™s knowledge of the trivia material used on the show, ignoring other strategic elements like wagering."
  },
  {
    "objectID": "posts/coryat_scores/coryat_scores.html#histogram",
    "href": "posts/coryat_scores/coryat_scores.html#histogram",
    "title": "Coryat Scores",
    "section": "Histogram",
    "text": "Histogram\n\ncoryat_scores |>\n  ggplot(aes(x = score)) +\n  geom_histogram(fill = \"#8D2AB5\") +\n  geom_hline(yintercept = 1:15, col = \"white\") +\n  geom_vline(xintercept = seq(500,29500,1000), col = \"white\") +\n  scale_x_continuous(labels=scales::label_dollar()) +\n  theme_bw() +\n  labs(title = \"Distribution of Coryat Scores\", \n       x = \"Score\", \n       y = \"Count of Games\")"
  },
  {
    "objectID": "posts/coryat_scores/coryat_scores.html#line-chart",
    "href": "posts/coryat_scores/coryat_scores.html#line-chart",
    "title": "Coryat Scores",
    "section": "Line Chart",
    "text": "Line Chart\n\ncoryat_scores |>\n  ggplot(aes(x = game, y = score)) +\n  geom_point(color = \"#8D2AB5\") +\n  geom_line(color = \"#8D2AB5\", linetype = \"dotted\") +\n  ylim(0, 30000) +\n  scale_y_continuous(labels=scales::label_dollar()) +\n  theme_bw() +\n  labs(title = \"Coryat Score Trend\", x = \"Time\", y = \"Score\")"
  },
  {
    "objectID": "posts/crossword_times/crossword_times.html",
    "href": "posts/crossword_times/crossword_times.html",
    "title": "Crossword Times",
    "section": "",
    "text": "Down For Across is a website which allows you to solve user-uploaded crosswords solo or with friends.\nThe crosswords published in major American newspapers often differ in difficulty according to the day of the week. For example, the New York Timesâ€™ guide explains that their Monday puzzles are the easiest and their Saturday puzzles the hardest. Meanwhile, the Sunday puzzles have easy clues but a large grid, and the Thursday puzzles have some unique gimmick. By contrast, the New Yorkerâ€™s crosswords decrease in difficulty over the week.\nIâ€™ve started keeping track of my solo completion times for the New York Times, Los Angeles Times, New Yorker, and Wall Street Journal crosswords."
  },
  {
    "objectID": "posts/crossword_times/crossword_times.html#boxplot",
    "href": "posts/crossword_times/crossword_times.html#boxplot",
    "title": "Crossword Times",
    "section": "Boxplot",
    "text": "Boxplot\nlubridate provides convenient date and time parsing functions like ms. weekdays(as.Date('1970-01-01') + 4:10) is a nice trick to produce a character vector with the names of the week, beginning with Monday.12\n\nread_csv(\"crossword_times.csv\", col_types = \"ccD\") |>\n  ggplot(aes(x = factor(weekdays(Date), \n                        weekdays(as.Date('1970-01-01') + 4:10)),\n             y = period_to_seconds(ms(Time))/60, \n             fill = Publisher)) +\n  geom_boxplot() +\n  scale_x_discrete(labels = c(\"M\", \"T\", \"W\", \"T\", \"F\", \"S\", \"S\")) +\n  facet_wrap(~Publisher) +\n  guides(fill = FALSE) + \n  labs(title = \"Crossword Completion Times\", \n           x = \"Day of the Week\",\n           y = \"Completion Time (Minutes, Log Scale)\")\n\n\n\n\n\nTab 1Tab 2"
  },
  {
    "objectID": "posts/coryat_scores/coryat_scores.html#average-score",
    "href": "posts/coryat_scores/coryat_scores.html#average-score",
    "title": "Coryat Scores",
    "section": "Average Score",
    "text": "Average Score\nAn average score of around $25,000 is considered appropriate for prospective contestants.\n\n# calculate my mean score\ncoryat_scores |&gt; pull(score) |&gt; mean() |&gt; round()\n\n[1] 19308\n\n\nClearly, I have some studying to do before I consider trying to compete on the show."
  },
  {
    "objectID": "posts/coryat_scores/coryat_scores.html#visualizing-scores",
    "href": "posts/coryat_scores/coryat_scores.html#visualizing-scores",
    "title": "Coryat Scores",
    "section": "Visualizing Scores",
    "text": "Visualizing Scores\nWe can create a histogram showing the distribution of my scores and a line chart showing the evolution of my scores over time using ggplot2.\n\nEmpirical Cumulative DistributionLine Chart and Histogram\n\n\n\n\nCode\ncoryat_scores |&gt;\n  arrange(score) |&gt;\n  ggplot(aes(x = score, y = cumsum(score)/sum(score))) +\n  geom_line(color = \"#8D2AB5\", size = 2) +\n  scale_x_continuous(labels = scales::label_dollar(), n.breaks = 6) +\n  scale_y_continuous(labels = scales::label_percent()) +\n  labs(title = \"Coryat Score Cumulative Distribution\", \n       x = \"Score\", \n       y = \"Percentile\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n(coryat_scores |&gt;\n  ggplot(aes(x = game, y = score)) +\n  geom_point(colour = \"#8D2AB5\") +\n  geom_line(colour = \"#8D2AB5\", linetype = \"dotted\") +\n  ylim(0, 30000) +\n  scale_y_continuous(labels=scales::label_dollar(), n.breaks = 6) +\n  stat_smooth(colour = \"magenta\", linetype = \"dashed\") +\n  labs(title = \"Coryat Score Trend and Histogram\", x = \"Game\", y = \"Score\")) |&gt;\n  ggMarginal(type = \"histogram\", margins = \"y\", fill = \"#8D2AB5\")"
  },
  {
    "objectID": "posts/coryat_scores/coryat_scores.html#references",
    "href": "posts/coryat_scores/coryat_scores.html#references",
    "title": "Coryat Scores",
    "section": "References",
    "text": "References\n\nJ! Scorer\nJ! Archive\nJ!ometry"
  },
  {
    "objectID": "posts/crossword_times/crossword_times.html#references",
    "href": "posts/crossword_times/crossword_times.html#references",
    "title": "Crossword Times",
    "section": "References",
    "text": "References\n\nHow to Solve The New York Times Crossword\nAnna Shechtman, the new queen of crosswords"
  },
  {
    "objectID": "posts/crossword_times/crossword_times.html#visualizing-solve-times",
    "href": "posts/crossword_times/crossword_times.html#visualizing-solve-times",
    "title": "Crossword Times",
    "section": "Visualizing Solve Times",
    "text": "Visualizing Solve Times\nIâ€™m accustomed to thinking of the week as beginning with Sunday, but for the purposes of crossword difficulty analysis, Monday is better.\n\nScatterplotBox Plots\n\n\n\n\nCode\nseq(from = 0, to = 65, by = 5) -&gt;\n  breaks\n\nread_csv(\"crossword_times.csv\", col_types = \"ccD\") |&gt;\n  transmute(Publisher,\n            day = factor(wday(Date, week_start = 1)),\n            minutes = period_to_seconds(ms(Time))/60) |&gt;\n  ggplot() +\n  aes(x = day, y = minutes, fill = Publisher) +\n  geom_vline(xintercept = 1.5:6.5, color = \"white\") + \n  geom_hline(yintercept = breaks, color = \"white\") +\n  scale_x_discrete(labels = c(\"M\", \"T\", \"W\", \"T\", \"F\", \"S\", \"S\")) +\n  scale_y_continuous(breaks = breaks) + \n  facet_grid(cols = vars(Publisher)) +\n  guides(fill = FALSE) +\n  labs(title = \"Crossword Completion Times\",\n       x = \"Day of the Week\",\n       y = \"Completion Time (Minutes)\") +\n  theme(panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank()) -&gt;\n  plot\n\nplot +\n  geom_point(shape = 21, alpha = 0.4, size = 3)\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot +\n  geom_boxplot()"
  },
  {
    "objectID": "posts/books_no_one_else_has/books_no_one_else_has.html",
    "href": "posts/books_no_one_else_has/books_no_one_else_has.html",
    "title": "Books No One Else Has",
    "section": "",
    "text": "LibraryThing is a site for storing and sharing book catalogues. It currently has about 3 million users and 183 million books catalogued.\nThese are the books on my shelves which appear in no other userâ€™s catalogue. (As of 2023-02-04.)"
  },
  {
    "objectID": "posts/books_no_one_else_has/books_no_one_else_has.html#èµ¤å³°å¹¸ç”Ÿã®æš®ã—ã£ã-by-eisuke-yamashita",
    "href": "posts/books_no_one_else_has/books_no_one_else_has.html#èµ¤å³°å¹¸ç”Ÿã®æš®ã—ã£ã-by-eisuke-yamashita",
    "title": "Books No One Else Has",
    "section": "èµ¤å³°å¹¸ç”Ÿã®æš®ã—ã£ã by Eisuke Yamashita",
    "text": "èµ¤å³°å¹¸ç”Ÿã®æš®ã—ã£ã by Eisuke Yamashita\nThis is a coffee table book of photos of the worldâ€™s most stylish man, Yukio Akamine. Derek Guy interviewed the author for Put This On here.\nThis is a boutique, foreign-language publication on a niche subject, which I expect explains why it doesnâ€™t appear in anyone elseâ€™s catalogue."
  },
  {
    "objectID": "posts/books_no_one_else_has/books_no_one_else_has.html#an-introduction-to-the-logic-of-the-sciences-by-rom-harrÃ©",
    "href": "posts/books_no_one_else_has/books_no_one_else_has.html#an-introduction-to-the-logic-of-the-sciences-by-rom-harrÃ©",
    "title": "Books No One Else Has",
    "section": "An Introduction to the Logic of the Sciences by Rom HarrÃ©",
    "text": "An Introduction to the Logic of the Sciences by Rom HarrÃ©"
  },
  {
    "objectID": "posts/books_no_one_else_has/books_no_one_else_has.html#dicionario-de-la-10.000-radiki-di-la-linguo-universala-ido-by-marcel-peach",
    "href": "posts/books_no_one_else_has/books_no_one_else_has.html#dicionario-de-la-10.000-radiki-di-la-linguo-universala-ido-by-marcel-peach",
    "title": "Books No One Else Has",
    "section": "Dicionario de la 10.000 Radiki di la Linguo Universala Ido by Marcel Peach",
    "text": "Dicionario de la 10.000 Radiki di la Linguo Universala Ido by Marcel Peach\nA self-published dictionary of the would-be successor to Esperanto. Itâ€™s somewhat dated (e.g.Â â€œdi laâ€ is usually â€œdilâ€ today) and Ido is only spoken by a very small community of enthusiasts. Iâ€™m surprised none of the collections of any of the various Esperanto organizations, some of which are very extensive, contain it."
  },
  {
    "objectID": "posts/books_no_one_else_has/books_no_one_else_has.html#on-the-choice-of-a-common-language-by-h.-jacob",
    "href": "posts/books_no_one_else_has/books_no_one_else_has.html#on-the-choice-of-a-common-language-by-h.-jacob",
    "title": "Books No One Else Has",
    "section": "On the Choice of a Common Language by H. Jacob",
    "text": "On the Choice of a Common Language by H. Jacob\nAnother artifact from the era of peak public interest in auxiliary languages."
  },
  {
    "objectID": "posts/books_no_one_else_has/books_no_one_else_has.html#logical-methods-by-greg-restall-and-shawn-standefer",
    "href": "posts/books_no_one_else_has/books_no_one_else_has.html#logical-methods-by-greg-restall-and-shawn-standefer",
    "title": "Books No One Else Has",
    "section": "Logical Methods by Greg Restall and Shawn Standefer",
    "text": "Logical Methods by Greg Restall and Shawn Standefer\nIn his review, Peter Smith calls this a â€œan introduction to some aspects of formal logic that are of particular philosophical interestâ€. Unusually, it covers propositional modal logic before developing first-order logic.\nThis is a newly-released book and Iâ€™m sure it will fall off this list once a few more university lecturers start using it in their courses."
  },
  {
    "objectID": "posts/books_no_one_else_has/books_no_one_else_has.html#tidy-modeling-with-r-a-framework-for-modeling-in-the-tidyverse-by-max-kuhn-and-julia-silge",
    "href": "posts/books_no_one_else_has/books_no_one_else_has.html#tidy-modeling-with-r-a-framework-for-modeling-in-the-tidyverse-by-max-kuhn-and-julia-silge",
    "title": "Books No One Else Has",
    "section": "Tidy Modeling with R: A Framework for Modeling in the Tidyverse by Max Kuhn and Julia Silge",
    "text": "Tidy Modeling with R: A Framework for Modeling in the Tidyverse by Max Kuhn and Julia Silge\nThis is an Oâ€™Reilly book about the tidymodels framework for statistical inference and machine learning in R. Iâ€™m a bit surprised that no other users have this yet. Maybe Python is just too popular."
  },
  {
    "objectID": "posts/books_no_one_else_has/books_no_one_else_has.html#myndlistardeild-listahÃ¡skÃ³la-Ã­slands-Ãºtskriftarverkefni-2022-by-bjarki-bragason",
    "href": "posts/books_no_one_else_has/books_no_one_else_has.html#myndlistardeild-listahÃ¡skÃ³la-Ã­slands-Ãºtskriftarverkefni-2022-by-bjarki-bragason",
    "title": "Books No One Else Has",
    "section": "Myndlistardeild ListahÃ¡skÃ³la Ãslands: Ãºtskriftarverkefni 2022 by Bjarki Bragason",
    "text": "Myndlistardeild ListahÃ¡skÃ³la Ãslands: Ãºtskriftarverkefni 2022 by Bjarki Bragason\nThis is the book for the 2022 graduation exhibition of the Iceland University of the Arts. Iâ€™m not surprised no one on the site else has this."
  },
  {
    "objectID": "posts/books_no_one_else_has/books_no_one_else_has.html#errÃ³-the-power-of-images",
    "href": "posts/books_no_one_else_has/books_no_one_else_has.html#errÃ³-the-power-of-images",
    "title": "Books No One Else Has",
    "section": "ErrÃ³: The Power of Images",
    "text": "ErrÃ³: The Power of Images\nAnother exhibition book from Iceland, this one from an ErrÃ³ retrospective."
  },
  {
    "objectID": "posts/books_no_one_else_has/books_no_one_else_has.html#the-lopi-sweater-knitting-book-by-grÃ©ta-sÃ¶rensen",
    "href": "posts/books_no_one_else_has/books_no_one_else_has.html#the-lopi-sweater-knitting-book-by-grÃ©ta-sÃ¶rensen",
    "title": "Books No One Else Has",
    "section": "The Lopi Sweater Knitting Book by GrÃ©ta SÃ¶rensen",
    "text": "The Lopi Sweater Knitting Book by GrÃ©ta SÃ¶rensen"
  },
  {
    "objectID": "posts/books_no_one_else_has/books_no_one_else_has.html#skÃ¡klist---32-pieces-the-art-of-chess-by-mark-sanders",
    "href": "posts/books_no_one_else_has/books_no_one_else_has.html#skÃ¡klist---32-pieces-the-art-of-chess-by-mark-sanders",
    "title": "Books No One Else Has",
    "section": "SkÃ¡klist - 32 Pieces: The Art of Chess by Mark Sanders",
    "text": "SkÃ¡klist - 32 Pieces: The Art of Chess by Mark Sanders"
  },
  {
    "objectID": "posts/books_no_one_else_has/books_no_one_else_has.html#mondrian-and-the-neo-plasticist-utopia-by-serge-fauchereau",
    "href": "posts/books_no_one_else_has/books_no_one_else_has.html#mondrian-and-the-neo-plasticist-utopia-by-serge-fauchereau",
    "title": "Books No One Else Has",
    "section": "Mondrian and the Neo-Plasticist Utopia by Serge Fauchereau",
    "text": "Mondrian and the Neo-Plasticist Utopia by Serge Fauchereau"
  },
  {
    "objectID": "posts/books_no_one_else_has/books_no_one_else_has.html#coffee-table-books-from-iceland",
    "href": "posts/books_no_one_else_has/books_no_one_else_has.html#coffee-table-books-from-iceland",
    "title": "Books No One Else Has",
    "section": "Coffee Table Books from Iceland",
    "text": "Coffee Table Books from Iceland\n\nMyndlistardeild ListahÃ¡skÃ³la Ãslands: Ãºtskriftarverkefni 2022 by Bjarki Bragason\nThis is the book for the 2022 graduation exhibition of the Iceland University of the Arts. Iâ€™m not surprised no one on the site else has this.\n\n\nErrÃ³: The Power of Images\nAnother exhibition book from Iceland, this one from an ErrÃ³ retrospective at the ReykjavÃ­k Art Museum.\n\n\nSkÃ¡klist - 32 Pieces: The Art of Chess by Mark Sanders\nThe Art of Chess is a travelling exhibition of interesting chess sets. Although I wasnâ€™t able to see it, the book from its stop in Iceland makes a nice addition to my collection of books about chess sets.\n\n\nStakkurinn - The Coat\nA pictorial history of (and fairly compelling advertisement for) the outerwear company 66Â°N."
  },
  {
    "objectID": "posts/wordle_scores/wordle_scores.html",
    "href": "posts/wordle_scores/wordle_scores.html",
    "title": "Wordle Scores",
    "section": "",
    "text": "Unless you spent 2022 on the moon, youâ€™ve heard of Wordle. Here I present the results of my word-guessery."
  },
  {
    "objectID": "posts/wordle_scores/wordle_scores.html#visualizing-wordle-scores",
    "href": "posts/wordle_scores/wordle_scores.html#visualizing-wordle-scores",
    "title": "Wordle Scores",
    "section": "Visualizing Wordle Scores",
    "text": "Visualizing Wordle Scores\n\nLine Chart with Marginal Histogram\n\n\nCode\n(wordle_scores |&gt;\n  ggplot(aes(x = puzzle, y = score)) +\n  geom_point(colour = \"#6AAA64\") +\n  geom_smooth(colour = \"#D1B036\", linetype = \"dashed\") +\n  scale_y_continuous(limits = c(0.75, 7.25), breaks = 1:7, labels = c(1:6, \"â‰¥7\")) +\n  labs(title = \"Wordle Score Trend and Histogram\", \n       x = \"Puzzle Number\", \n       y = \"Score\",\n       caption = \"Dashed line indicates mean score with optimal play.\") +\n  geom_hline(yintercept = 3.4201, linetype = \"dashed\") +\n  theme(panel.grid.minor = element_blank())) |&gt;\n  ggMarginal(type = \"histogram\", \n             margins = \"y\", \n             fill = \"#6AAA64\",\n             yparams = list(bins = 7, center = 0, binwidth = 1))"
  },
  {
    "objectID": "posts/wordle_scores/wordle_scores.html#line-chart",
    "href": "posts/wordle_scores/wordle_scores.html#line-chart",
    "title": "Wordle Scores",
    "section": "Line Chart",
    "text": "Line Chart\n\n\nCode\nread_csv(\"wordle_scores.csv\") |>\n  ggplot(aes(x = puzzle, y = score)) +\n  geom_point(shape = 21, fill = \"green\") +\n  geom_line(aes(y = rollmean(score, 10, na.pad = TRUE)), \n            size = 1.5) +\n  scale_y_continuous(limits = c(0, 6)) +\n  labs(title = \"Wordle Scores Over Time\", \n       x = \"Puzzle Number\", \n       y = \"Score\",\n       subtitle = \"10-Puzzle Rolling Average\",\n       caption = \"Dashed line indicates my average score.\\nDotted line indicates average score with optimal play.\") +\n  geom_hline(yintercept = mean_score, linetype = \"dashed\") + \n  geom_hline(yintercept = 3.4201, linetype = \"dotted\")"
  },
  {
    "objectID": "posts/wordle_scores/wordle_scores.html#references",
    "href": "posts/wordle_scores/wordle_scores.html#references",
    "title": "Wordle Scores",
    "section": "References",
    "text": "References\n\nWordle-solving state of the art: all optimality results so far"
  },
  {
    "objectID": "posts/homeworlds_openings/homeworlds_openings.html",
    "href": "posts/homeworlds_openings/homeworlds_openings.html",
    "title": "Homeworlds Openings",
    "section": "",
    "text": "Homeworlds is an abstract space battle game designed by John Cooper and published by Looney Labs. Itâ€™s played with multipurpose game pieces called Looney pyramids, three of each of combination of three sizes (small, medium, and large) and four colours (green, yellow, blue, and red) for 36 in total. A pyramid lying down is a space ship and a pyramid standing up is a star. Each colour is associated with an ability.\nAt the beginning of the game, each player chooses two stars to be their homeworld. Star systems are connected if they have no sizes in common.\n\n\n\nHomeworlds star connection rule (from Looney Labs)\n\n\nExpert players actively debate Homeworldsâ€™ opening theory. One question is which combination of star sizes should be selected by the first player, and how the second player should respond.\n\n\n\nSome homeworld options (from Looney Labs)\n\n\nWhen playersâ€™ homeworlds are one step away from one another (i.e.Â connected), this is known as a â€œmicroverseâ€. If they are two steps away, thatâ€™s a â€œsmall universeâ€, and if they are three steps away, thatâ€™s a â€œlarge universeâ€.\nIn addition to their homeworld stars, each player selects a pyramid to be their first ship. The rest of the pieces become the bank from which new stars and ships are taken and to which destroyed stars and ships are returned."
  },
  {
    "objectID": "posts/homeworlds_openings/homeworlds_openings.html#data",
    "href": "posts/homeworlds_openings/homeworlds_openings.html#data",
    "title": "Homeworlds Openings",
    "section": "Data",
    "text": "Data\nBabamots compiled information from 4928 games of Homeworlds played on BoardGameArena and provided a first player win rate and a count of observations for each combination of first and second player homeworld sizes. Draws were counted as half a win for each player. Only games that lasted at least eight turns for each player were included.\n\n\nCode\nread_csv(\"raw_data.csv\") -> raw_data\n\nraw_data\n\n\n# A tibble: 36 Ã— 4\n   p1_wr     n p1_hw p2_hw\n   <dbl> <dbl> <chr> <chr>\n 1 0.175    20 SS    SM   \n 2 0.2      10 SS    ML   \n 3 0.25      4 SS    LL   \n 4 0.292    12 SS    SL   \n 5 0.385    13 SL    MM   \n 6 0.393    28 ML    MM   \n 7 0.408    71 SM    MM   \n 8 0.409    22 ML    SS   \n 9 0.441    34 ML    LL   \n10 0.449   476 SL    SM   \n# â„¹ 26 more rows\n\n\nWeâ€™ll also create some helper vectors and functions that will be convenient later.\n\n# helper vectors\n#c(\"SS\", \"SM\", \"SL\", \"MM\", \"ML\", \"LL\") -> hw_sizes\nc(\"SM\", \"SL\", \"ML\", \"SS\", \"MM\", \"LL\") -> hw_sizes\nc(\"micro\", \"small\", \"large\") -> universe_sizes\n\n# list the stars in a homeworld\n(function(hw) {unlist(strsplit(as.character(hw), \"\"))}) -> stars\n\n# determine the universe size\n(function(hw1, hw2) {\n  case_when(length(intersect(stars(hw1), stars(hw2))) == 0 ~ \"micro\",\n            length(unique(c(stars(hw1), stars(hw2)))) <= 2 ~ \"small\",\n            T ~ \"large\")}) -> universe_size"
  },
  {
    "objectID": "posts/homeworlds_openings/homeworlds_openings.html#modelling-first-player-advantage",
    "href": "posts/homeworlds_openings/homeworlds_openings.html#modelling-first-player-advantage",
    "title": "Homeworlds Openings",
    "section": "Modelling First Player Advantage",
    "text": "Modelling First Player Advantage\nWe can model first player advantage by imagining that a game of Homeworlds is like a biased coin flip, where each opening is associated with an independent bias. For example, if the bias parameter for some opening is 0.6, then we expect the first player to win 60% of the time that opening is played.1\nIf this parameter is distributed according to a beta distribution Beta(a, b), then its posterior distribution accounting for observing n wins and m losses for the first player is Beta(a + n, b + m).2 All that is left is to decide on a prior distribution representing our beliefs before observing any data. This is an interesting subtlety3, but it seems reasonable to choose a uniform prior, Beta(1, 1), under which all possibilities are equally credible.\nFrom the posterior distribution, we can construct a 90% credible interval using qbeta. Unlike the confidence intervals used in frequentist statistical inference, which are the source of much confusion, Bayesian credible intervals have a straightforward interpretation: weâ€™re 90% sure the true value of the parameter is contained in a 90% credible interval.4\nWe can also calculate the probability that the first player is favoured (i.e.Â is expected to win at least half the time) in each opening using pbeta. In this case we donâ€™t consider the extent of the advantage, just whether there is one.\n\n\nCode\nraw_data |>\n  mutate(across(c(p1_hw, p2_hw), \n                \\(x) factor(x, ordered = T, levels = hw_sizes))) |>\n  rowwise() |>\n  mutate(p1_wins = n*p1_wr,\n         p2_wins = n*(1 - p1_wr),\n         # calculate a 90% credible interval from the posterior distribution\n         ci_lower = qbeta(c(0.05, 0.95), 1 + p1_wins, 1 + p2_wins)[1],\n         ci_upper = qbeta(c(0.05, 0.95), 1 + p1_wins, 1 + p2_wins)[2],\n         # format the interval as text\n         formatted_ci = paste0(round(100 * ci_lower),\n                               \"-\",\n                               round(100 * ci_upper),\n                               \"%\"),\n         # bold intervals that do not contain 50%\n         ci_fontface = case_when(!between(0.5, ci_lower, ci_upper) ~ \"bold\",\n                                 T ~ \"plain\"),\n         universe_size = universe_size(p1_hw, p2_hw),\n         universe_size = factor(universe_size, ordered = T, levels = universe_sizes),\n         prob_fav = 1 - pbeta(0.5, 1 + p1_wins, 1 + p2_wins),\n         formatted_prob_fav = case_when(\n           prob_fav < 0.005 ~ \"<1%\",\n           prob_fav < 0.995 ~ paste0(round(100 * prob_fav), \"%\"),\n           T ~ \">99%\"),\n         prob_fav_fontface = case_when(abs(prob_fav - 0.5) > 0.45 ~ \"bold\", T ~ \"plain\")) |>\n  arrange(p1_hw, p2_hw) ->\n  homeworlds_openings\n\nhomeworlds_openings\n\n\n# A tibble: 36 Ã— 14\n# Rowwise: \n   p1_wr     n p1_hw p2_hw p1_wins p2_wins ci_lower ci_upper formatted_ci\n   <dbl> <dbl> <ord> <ord>   <dbl>   <dbl>    <dbl>    <dbl> <chr>       \n 1 0.643   300 SM    SM     193.   107.       0.596    0.687 60-69%      \n 2 0.486   590 SM    SL     287.   303.       0.452    0.520 45-52%      \n 3 0.495   813 SM    ML     402.   411.       0.466    0.524 47-52%      \n 4 0.667     3 SM    SS       2.00   0.999    0.249    0.903 25-90%      \n 5 0.408    71 SM    MM      29.0   42.0      0.318    0.506 32-51%      \n 6 0.51     52 SM    LL      26.5   25.5      0.398    0.620 40-62%      \n 7 0.449   476 SL    SM     214.   262.       0.412    0.487 41-49%      \n 8 0.604   130 SL    SL      78.5   51.5      0.532    0.671 53-67%      \n 9 0.502   430 SL    ML     216.   214.       0.462    0.542 46-54%      \n10 0.667     6 SL    SS       4.00   2.00     0.342    0.871 34-87%      \n# â„¹ 26 more rows\n# â„¹ 5 more variables: ci_fontface <chr>, universe_size <ord>, prob_fav <dbl>,\n#   formatted_prob_fav <chr>, prob_fav_fontface <chr>"
  },
  {
    "objectID": "posts/homeworlds_openings/homeworlds_openings.html#visualizing-first-player-advantage",
    "href": "posts/homeworlds_openings/homeworlds_openings.html#visualizing-first-player-advantage",
    "title": "Homeworlds Openings",
    "section": "Visualizing First Player Advantage",
    "text": "Visualizing First Player Advantage\n\nCredible IntervalsPosterior Probability of First Player Advantage\n\n\n\n\nCode\nhomeworlds_openings |>\n  ggplot(aes(x = p1_hw, y = p2_hw, fill = p1_wr)) +\n  # add tiles coloured to indicate the observed first player win rate\n  geom_tile(width = 0.8, height = 0.8) +\n  # add dots to indicate universe size\n  geom_point(aes(colour = universe_size), \n             position = position_nudge(x = 0.3, y = 0.3), \n             size = 3) +\n  # trick to circle the universe size dots without a fill scale collision\n  geom_point(size = 3, \n             shape = 21, \n             fill = NA, \n             colour = \"black\", \n             position = position_nudge(x = 0.3, y = 0.3)) +\n  # add labels\n  labs(title = \"Homeworlds First Player Advantage by Opening\",\n       x = \"First Player's Homeworld Sizes\",\n       y = \"Second Player's Homeworld Sizes\",\n       fill = \"Observed First Player\\nWin Rate\",\n       colour = \"Universe Size\") +\n  # gradient scale for the tiles\n  scale_fill_gradient2(low = \"red\", \n                       mid = \"white\", \n                       high = \"blue\", \n                       midpoint = 0.5,\n                       labels = scales::percent,\n                       limits = c(0, 1)) +\n  # discrete scale for the universe size dots\n  scale_colour_manual(values = c(micro = \"white\", \n                                 small = \"grey50\", \n                                 large = \"black\")) + \n  scale_y_discrete(limits = rev) +\n  # put the win rate legend under the universe size legend\n  guides(colour = guide_legend(order = 1)) ->\n  plot\n\nplot +\n  # add formatted credible intervals as text\n  geom_text(aes(label = formatted_ci, fontface = ci_fontface)) +\n  # add subtitle\n  labs(subtitle = \"90% Bayesian credible intervals with uniform priors\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nplot + \n  # add posterior probability first player is favoured as text\n  geom_text(aes(label = formatted_prob_fav, fontface = prob_fav_fontface)) +\n  # add subtitle\n  labs(subtitle = \"Posterior probability first player is favoured\")"
  },
  {
    "objectID": "posts/homeworlds_openings/homeworlds_openings.html#observations",
    "href": "posts/homeworlds_openings/homeworlds_openings.html#observations",
    "title": "Homeworlds Openings",
    "section": "Observations",
    "text": "Observations\nIt seems that the first player should probably choose a large-large or medium-medium homeworld configuration. A homeworld with equally-sized stars is known as a â€œGeminiâ€ configuration. When the first player chooses a Gemini opening, the second player loses the option of creating a large universe; only a small or a microverse is possible.\nThe second player should opt for a small universe rather than a microverse. (A large universe is not possible when the first playerâ€™s homeworld contains stars of equal size.)\nWhy isnâ€™t small-small also advantageous for the first player? This is likely due to creating a bank configuration which will provide better lines of play to the second player in the early turns of the game."
  },
  {
    "objectID": "posts/homeworlds_openings/homeworlds_openings.html#confounding-variables",
    "href": "posts/homeworlds_openings/homeworlds_openings.html#confounding-variables",
    "title": "Homeworlds Openings",
    "section": "Confounding Variables",
    "text": "Confounding Variables\nOne might reasonably object to the model described above. For one thing, it does not take into account the colours of the pieces selected. This is a relatively minor issue, however, since a certain combination of colours5 is almost universally chosen.\nMore concerning is the potentially confounding effect of player skill. Itâ€™s very possible that some openings may be effective only in the hands of experts. It would be interesting to revisit this analysis with more granular and detailed data that included Elo ratings. You can help with this by learning Homeworlds!\nYou can buy a Homeworlds set from Looney Labs. The same pieces can also be used to play many other interesting games."
  },
  {
    "objectID": "posts/homeworlds_openings/homeworlds_openings.html#conclusions",
    "href": "posts/homeworlds_openings/homeworlds_openings.html#conclusions",
    "title": "Homeworlds Openings",
    "section": "Conclusions",
    "text": "Conclusions\nIf youâ€™re playing first, start with two large stars of blue and yellow, and a large green ship. If youâ€™re playing second and your opponent has followed my advice, try small-large or large-large in the same colours."
  },
  {
    "objectID": "posts/homeworlds_openings/homeworlds_openings.html#references",
    "href": "posts/homeworlds_openings/homeworlds_openings.html#references",
    "title": "Homeworlds Openings",
    "section": "References",
    "text": "References\n\nHomeworlds | Looney Labs\nPlay Homeworlds Online | BoardGameArena\nLooney Labsâ€™ Online Store\nBabamotsâ€™ Homeworlds Site\nAndyâ€™s Page About Homeworlds\nHomeworlds | Board Game | BoardGameGeek"
  },
  {
    "objectID": "posts/crossword_times/crossword_times.html#introduction",
    "href": "posts/crossword_times/crossword_times.html#introduction",
    "title": "Crossword Times",
    "section": "",
    "text": "Down For Across is a website which allows you to solve user-uploaded crosswords solo or with friends.\nThe crosswords published in major American newspapers often differ in difficulty according to the day of the week. For example, the New York Timesâ€™ guide explains that their Monday puzzles are the easiest and their Saturday puzzles the hardest. Meanwhile, the Sunday puzzles have easy clues but a large grid, and the Thursday puzzles have some unique gimmick. By contrast, the New Yorkerâ€™s crosswords decrease in difficulty over the week.\nIâ€™ve started keeping track of my solo completion times for the New York Times, Los Angeles Times, New Yorker, and Wall Street Journal crosswords."
  },
  {
    "objectID": "posts/wordle_scores/wordle_scores.html#introduction",
    "href": "posts/wordle_scores/wordle_scores.html#introduction",
    "title": "Wordle Scores",
    "section": "",
    "text": "Unless you spent 2022 on the moon, youâ€™ve heard of Wordle. Here I present the results of my word-guessery."
  },
  {
    "objectID": "posts/coryat_scores/coryat_scores.html#jeopardy-coryat-scores",
    "href": "posts/coryat_scores/coryat_scores.html#jeopardy-coryat-scores",
    "title": "Coryat Scores",
    "section": "",
    "text": "The Coryat score is a way of measuring oneâ€™s performance when playing along with Jeopardy! at home. It is named after musician, philosopher of physics, and two-day Jeopardy! champion Karl Coryat.\nA playerâ€™s Coryat score is the total value of clues answered correctly, minus that of those answered incorrectly, counting correctly-answered Daily Doubles according to their board position and ignoring Final Jeopardy! and any incorrectly-answered Daily Doubles.\nThus the Coryat score is a measure of oneâ€™s knowledge of the trivia material used on the show, ignoring other strategic elements like wagering."
  },
  {
    "objectID": "posts/wordle_scores/wordle_scores.html#line-chart-with-marginal-histogram",
    "href": "posts/wordle_scores/wordle_scores.html#line-chart-with-marginal-histogram",
    "title": "Wordle Scores",
    "section": "Line Chart with Marginal Histogram",
    "text": "Line Chart with Marginal Histogram\n\n\nCode\n(read_csv(\"wordle_scores.csv\") |&gt;\n  ggplot(aes(x = puzzle, y = score)) +\n  geom_point(shape = 21, fill = \"#EBEBEB\") +\n  geom_smooth() +\n  scale_y_continuous(limits = c(0.5, 7.5), breaks = 1:7, labels = c(1:6, \"â‰¥7\")) +\n  labs(title = \"Wordle Scores Over Time\", \n       x = \"Puzzle Number\", \n       y = \"Score\",\n       caption = paste0(\"My average score: \", \n                        round(mean_score, 2) ,\n                        \"\\nAverage score with optimal play: 3.42\")) +\n  geom_hline(yintercept = mean_score, linetype = \"dashed\") + \n  geom_hline(yintercept = 3.4201, linetype = \"dotted\") +\n  theme_clean()) |&gt;\n  ggMarginal(type = \"histogram\", margins = \"y\", yparams = list(bins = 7, center = 0, binwidth = 1, fill = \"#EBEBEB\"))"
  },
  {
    "objectID": "posts/wordle_scores/wordle_scores.html#reading-the-data",
    "href": "posts/wordle_scores/wordle_scores.html#reading-the-data",
    "title": "Wordle Scores",
    "section": "Reading the Data",
    "text": "Reading the Data\n\n\nCode\nread_csv(\"wordle_scores.csv\") -&gt;\n  wordle_scores"
  },
  {
    "objectID": "posts/wordle_scores/wordle_scores.html#average-score",
    "href": "posts/wordle_scores/wordle_scores.html#average-score",
    "title": "Wordle Scores",
    "section": "Average Score",
    "text": "Average Score"
  }
]